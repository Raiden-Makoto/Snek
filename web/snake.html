<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden;
        }
        
        #game-container {
            text-align: center;
            position: relative;
        }
        
        canvas {
            border: 3px solid #333;
            background: #000;
            display: block;
            margin: 0 auto;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="720" height="800"></canvas>
        <div id="loading">Loading...</div>
    </div>

    <script>
        // ==================== Game Constants ====================
        const GameConstants = {
            BOARD_SIZE: 720,
            SCORE_AREA_HEIGHT: 80,
            SCREEN_WIDTH: 720,
            SCREEN_HEIGHT: 800,
            CELL_SIZE: 30,
            GRID_WIDTH: (720 / 30) - 2,  // 22
            GRID_HEIGHT: (720 / 30) - 2, // 22
            BORDER_OFFSET: 1,
            BOARD_START_Y: 80,
            
            // Colors
            GRAY_COLOR: '#121212',
            SNAKE_COLOR: '#329632',
            SNAKE_HEAD_COLOR: '#196419',
            POISON_COLOR: '#b57e6b',
            GOLD_COLOR: '#ffa500',
            ENCHANTED_GOLD_COLOR: '#ffff00',
            PURPLE_COLOR: '#ba55d3',
            
            // Timing
            MOVE_INTERVAL_REGULAR: 0.25,
            MOVE_INTERVAL_ACCELERATED: 0.20,
            IMMUNITY_DURATION: 10.0,
            WALL_IMMUNITY_DURATION: 10.0,
            CANNOT_EAT_DURATION: 10.0,
            PAUSE_DURATION: 0.5,
            RESUME_DELAY_DURATION: 2.0,
            
            // Apple settings
            MAX_APPLES: 12,
            MIN_APPLES: 2,
            DESPAWN_TIME_MIN: 13,
            DESPAWN_TIME_MAX: 18
        };

        // ==================== Game Types ====================
        const FoodType = {
            REGULAR: 0,
            POISONOUS: 1,
            POMME_PLUS: 2,
            POMME_SUPREME: 3,
            TELEPORT: 4
        };

        const GameMode = {
            MODE_REGULAR: 0,
            MODE_ACCELERATED: 1
        };

        // ==================== Game State ====================
        class GameState {
            constructor() {
                // Screens
                this.showModeSelection = true;
                this.showInstructions = false;
                this.gameOver = false;
                this.selectedModeIndex = 0;
                this.gameMode = GameMode.MODE_REGULAR;
                
                // Score
                this.score = 0;
                this.highScoreRegular = 0;
                this.highScoreAccelerated = 0;
                
                // Snake
                this.snake = [];
                this.dx = 0;
                this.dy = 0;
                this.directionQueue = [];
                this.moveTimer = 0.0;
                
                // Apples
                this.apples = [];
                this.gameTime = 0.0;
                
                // Status effects
                this.canIntersectSelf = false;
                this.immunityTimer = 0.0;
                this.canPassWalls = false;
                this.wallImmunityTimer = 0.0;
                this.cannotEatApples = false;
                this.cannotEatTimer = 0.0;
                
                // Pause states
                this.isPaused = false;
                this.pauseTimer = 0.0;
                this.isUserPaused = false;
                this.isResuming = false;
                this.resumeDelayTimer = 0.0;
                
                // Sound timers
                this.poisonSoundTimer = 0.0;
                this.pauseSoundTimer = 0.0;
                this.gameOverSoundPlayed = false;
            }
            
            getCurrentHighScore() {
                return this.gameMode === GameMode.MODE_ACCELERATED 
                    ? this.highScoreAccelerated 
                    : this.highScoreRegular;
            }
            
            updateHighScore() {
                if (this.gameMode === GameMode.MODE_ACCELERATED) {
                    if (this.score > this.highScoreAccelerated) {
                        this.highScoreAccelerated = this.score;
                    }
                } else {
                    if (this.score > this.highScoreRegular) {
                        this.highScoreRegular = this.score;
                    }
                }
            }
            
            isValidPosition(col, row) {
                // Check snake
                for (const segment of this.snake) {
                    if (col === segment.col && row === segment.row) {
                        return false;
                    }
                }
                // Check apples
                for (const apple of this.apples) {
                    if (col === apple.col && row === apple.row) {
                        return false;
                    }
                }
                return true;
            }
            
            getRandomFoodType() {
                const foodRoll = Math.floor(Math.random() * 100) + 1;
                if (foodRoll <= 4) return FoodType.POMME_PLUS;
                if (foodRoll <= 5) return FoodType.POMME_SUPREME;
                if (foodRoll <= 15) return FoodType.POISONOUS;
                if (foodRoll <= 18) return FoodType.TELEPORT;
                return FoodType.REGULAR;
            }
            
            spawnApple(currentTime) {
                if (this.apples.length >= GameConstants.MAX_APPLES) {
                    return false;
                }
                
                let attempts = 0;
                let col, row;
                do {
                    col = Math.floor(Math.random() * GameConstants.GRID_WIDTH);
                    row = Math.floor(Math.random() * GameConstants.GRID_HEIGHT);
                    attempts++;
                } while (!this.isValidPosition(col, row) && attempts < 100);
                
                if (attempts >= 100) {
                    return false;
                }
                
                const newApple = {
                    col: col,
                    row: row,
                    type: this.getRandomFoodType(),
                    spawnTime: currentTime,
                    despawnTime: GameConstants.DESPAWN_TIME_MIN + 
                                Math.random() * (GameConstants.DESPAWN_TIME_MAX - GameConstants.DESPAWN_TIME_MIN)
                };
                this.apples.push(newApple);
                return true;
            }
            
            reset() {
                this.gameOver = false;
                this.score = 0;
                this.gameTime = 0.0;
                
                this.snake = [];
                const startCol = Math.floor(Math.random() * GameConstants.GRID_WIDTH);
                const startRow = Math.floor(Math.random() * GameConstants.GRID_HEIGHT);
                this.snake.push({ col: startCol, row: startRow });
                
                this.apples = [];
                if (this.gameMode === GameMode.MODE_ACCELERATED) {
                    for (let i = 0; i < 3; i++) {
                        this.spawnApple(0.0);
                    }
                } else {
                    this.spawnApple(0.0);
                }
                
                this.dx = 0;
                this.dy = 0;
                this.directionQueue = [];
                this.moveTimer = 0.0;
                
                this.canIntersectSelf = false;
                this.immunityTimer = 0.0;
                this.canPassWalls = false;
                this.wallImmunityTimer = 0.0;
                this.cannotEatApples = false;
                this.cannotEatTimer = 0.0;
                this.isPaused = false;
                this.pauseTimer = 0.0;
                this.isUserPaused = false;
                this.isResuming = false;
                this.resumeDelayTimer = 0.0;
                this.poisonSoundTimer = 0.0;
                this.pauseSoundTimer = 0.0;
                this.gameOverSoundPlayed = false;
            }
        }

        // ==================== Sound Manager ====================
        class SoundManager {
            constructor() {
                this.sounds = {};
                this.audioContext = null;
                this.soundBuffers = {};
            }
            
            async init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const soundFiles = ['apple', 'poison', 'golden', 'purple', 'gameover', 'pause'];
                    
                    // Try multiple possible paths for sounds
                    const possiblePaths = [
                        'sounds/',           // Same directory as HTML
                        './sounds/',         // Explicit relative
                        '../sounds/',        // Parent directory
                        '/sounds/'           // Absolute (for web servers)
                    ];
                    
                    for (const sound of soundFiles) {
                        let loaded = false;
                        for (const path of possiblePaths) {
                            try {
                                const response = await fetch(`${path}${sound}.mp3`);
                                if (response.ok) {
                                    const arrayBuffer = await response.arrayBuffer();
                                    this.soundBuffers[sound] = await this.audioContext.decodeAudioData(arrayBuffer);
                                    loaded = true;
                                    break;
                                }
                            } catch (e) {
                                // Try next path
                                continue;
                            }
                        }
                        if (!loaded) {
                            console.warn(`Could not load sound: ${sound}.mp3 from any path`);
                        }
                    }
                } catch (e) {
                    console.warn('Audio not available', e);
                    console.warn('Game will continue without sound effects');
                }
            }
            
            play(soundName) {
                if (!this.audioContext || !this.soundBuffers[soundName]) {
                    return;
                }
                try {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = this.soundBuffers[soundName];
                    source.connect(this.audioContext.destination);
                    source.start(0);
                } catch (e) {
                    console.warn(`Could not play sound: ${soundName}`, e);
                }
            }
        }

        // ==================== Game Logic ====================
        class GameLogic {
            static processDirectionQueue(state) {
                if (state.directionQueue.length > 0) {
                    const nextDir = state.directionQueue[0];
                    if ((state.dx === 0 && state.dy === 0) || 
                        (nextDir.dx !== -state.dx || nextDir.dy !== -state.dy)) {
                        state.dx = nextDir.dx;
                        state.dy = nextDir.dy;
                    }
                    state.directionQueue.shift();
                }
            }
            
            static checkCollisions(state, newHead, soundManager) {
                // Check self collision
                let hitSelf = false;
                if (!state.canIntersectSelf) {
                    for (const segment of state.snake) {
                        if (newHead.col === segment.col && newHead.row === segment.row) {
                            hitSelf = true;
                            break;
                        }
                    }
                }
                
                if (hitSelf) {
                    state.snake.unshift(newHead);
                    state.updateHighScore();
                    state.gameOver = true;
                    if (!state.gameOverSoundPlayed) {
                        soundManager.play('gameover');
                        state.gameOverSoundPlayed = true;
                    }
                    return;
                }
                
                // Check if snake ate any apple
                let eatenAppleIndex = -1;
                let eatenFoodType = FoodType.REGULAR;
                for (let i = 0; i < state.apples.length; i++) {
                    if (newHead.col === state.apples[i].col && newHead.row === state.apples[i].row) {
                        eatenAppleIndex = i;
                        eatenFoodType = state.apples[i].type;
                        break;
                    }
                }
                
                // Move snake
                state.snake.unshift(newHead);
                
                if (eatenAppleIndex >= 0) {
                    GameLogic.handleAppleConsumption(state, eatenAppleIndex, soundManager);
                } else {
                    state.snake.pop();
                }
            }
            
            static handleAppleConsumption(state, eatenAppleIndex, soundManager) {
                const eatenFoodType = state.apples[eatenAppleIndex].type;
                state.apples.splice(eatenAppleIndex, 1);
                
                if (eatenFoodType === FoodType.POISONOUS) {
                    // Poisonous apple
                    state.isPaused = true;
                    state.pauseTimer = GameConstants.PAUSE_DURATION;
                    state.directionQueue = [];
                    
                    state.snake.reverse();
                    state.snake.pop();
                    
                    state.dx = -state.dx;
                    state.dy = -state.dy;
                    
                    state.cannotEatApples = true;
                    state.cannotEatTimer = GameConstants.CANNOT_EAT_DURATION;
                    state.poisonSoundTimer = 1.0;
                    
                    soundManager.play('poison');
                } else if (eatenFoodType === FoodType.TELEPORT) {
                    if (!state.cannotEatApples) {
                        // Purple apple - teleport
                        state.snake.shift();
                        const snakeLength = state.snake.length;
                        
                        let newHeadCol, newHeadRow;
                        let validTeleportPos = false;
                        do {
                            newHeadCol = Math.floor(Math.random() * GameConstants.GRID_WIDTH);
                            newHeadRow = Math.floor(Math.random() * GameConstants.GRID_HEIGHT);
                            validTeleportPos = state.isValidPosition(newHeadCol, newHeadRow);
                        } while (!validTeleportPos);
                        
                        const dirRoll = Math.floor(Math.random() * 4);
                        switch (dirRoll) {
                            case 0: state.dx = 0; state.dy = -1; break;
                            case 1: state.dx = 0; state.dy = 1; break;
                            case 2: state.dx = -1; state.dy = 0; break;
                            case 3: state.dx = 1; state.dy = 0; break;
                        }
                        
                        state.snake = [];
                        state.snake.push({ col: newHeadCol, row: newHeadRow });
                        
                        for (let i = 1; i < snakeLength; i++) {
                            let segCol = newHeadCol - state.dx * i;
                            let segRow = newHeadRow - state.dy * i;
                            
                            if (segCol < 0) segCol = 0;
                            if (segCol >= GameConstants.GRID_WIDTH) segCol = GameConstants.GRID_WIDTH - 1;
                            if (segRow < 0) segRow = 0;
                            if (segRow >= GameConstants.GRID_HEIGHT) segRow = GameConstants.GRID_HEIGHT - 1;
                            
                            state.snake.push({ col: segCol, row: segRow });
                        }
                        
                        state.directionQueue = [];
                        state.dx = 0;
                        state.dy = 0;
                        state.moveTimer = 0.0;
                        
                        soundManager.play('purple');
                    } else {
                        state.snake.pop();
                    }
                } else if (eatenFoodType === FoodType.POMME_PLUS || eatenFoodType === FoodType.POMME_SUPREME) {
                    // Pomme Plus or Pomme Supreme
                    state.score += 2;
                    state.updateHighScore();
                    
                    state.snake.push({...state.snake[state.snake.length - 1]});
                    state.canIntersectSelf = true;
                    state.immunityTimer = GameConstants.IMMUNITY_DURATION;
                    
                    if (eatenFoodType === FoodType.POMME_SUPREME) {
                        state.canPassWalls = true;
                        state.wallImmunityTimer = GameConstants.WALL_IMMUNITY_DURATION;
                    }
                    
                    soundManager.play('golden');
                } else {
                    // Regular apple
                    if (!state.cannotEatApples) {
                        state.score++;
                        state.updateHighScore();
                        state.snake.push({...state.snake[state.snake.length - 1]});
                        soundManager.play('apple');
                    } else {
                        state.snake.pop();
                    }
                }
                
                // Spawn new apples
                if (state.gameMode === GameMode.MODE_ACCELERATED) {
                    for (let i = 0; i < 3 && state.apples.length < GameConstants.MAX_APPLES; i++) {
                        state.spawnApple(state.gameTime);
                    }
                } else {
                    state.spawnApple(state.gameTime);
                }
            }
            
            static processMovement(state, deltaTime, soundManager) {
                if (state.gameOver || state.isUserPaused || state.isResuming) {
                    return;
                }
                
                if (!state.isPaused && !state.isUserPaused && !state.isResuming) {
                    state.moveTimer += deltaTime;
                }
                
                const moveInterval = state.gameMode === GameMode.MODE_ACCELERATED
                    ? GameConstants.MOVE_INTERVAL_ACCELERATED
                    : GameConstants.MOVE_INTERVAL_REGULAR;
                
                if (!state.isPaused && !state.isUserPaused && !state.isResuming && 
                    state.moveTimer >= moveInterval) {
                    state.moveTimer = 0.0;
                    
                    GameLogic.processDirectionQueue(state);
                    
                    if (state.dx !== 0 || state.dy !== 0) {
                        let newHead = {
                            col: state.snake[0].col + state.dx,
                            row: state.snake[0].row + state.dy
                        };
                        
                        // Check wall collision
                        if (state.canPassWalls) {
                            // Wrap around
                            if (newHead.col < 0) {
                                newHead.col = GameConstants.GRID_WIDTH - 1;
                            } else if (newHead.col >= GameConstants.GRID_WIDTH) {
                                newHead.col = 0;
                            }
                            if (newHead.row < 0) {
                                newHead.row = GameConstants.GRID_HEIGHT - 1;
                            } else if (newHead.row >= GameConstants.GRID_HEIGHT) {
                                newHead.row = 0;
                            }
                        } else {
                            // Normal wall collision
                            if (newHead.col < 0 || newHead.col >= GameConstants.GRID_WIDTH ||
                                newHead.row < 0 || newHead.row >= GameConstants.GRID_HEIGHT) {
                                state.updateHighScore();
                                state.gameOver = true;
                                if (!state.gameOverSoundPlayed) {
                                    soundManager.play('gameover');
                                    state.gameOverSoundPlayed = true;
                                }
                                return;
                            }
                        }
                        
                        if (!state.gameOver) {
                            GameLogic.checkCollisions(state, newHead, soundManager);
                        }
                    }
                }
            }
        }

        // ==================== Renderer ====================
        class Renderer {
            static drawModeSelectionScreen(ctx, state) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GameConstants.SCREEN_WIDTH, GameConstants.SCREEN_HEIGHT);
                
                // Title
                ctx.fillStyle = '#fff';
                ctx.font = '60px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SNAKE GAME', GameConstants.SCREEN_WIDTH / 2, 150);
                
                // Subtitle
                ctx.fillStyle = '#ffff00';
                ctx.font = '32px Arial';
                ctx.fillText('Select Game Mode', GameConstants.SCREEN_WIDTH / 2, 230);
                
                // Mode options
                ctx.font = '36px Arial';
                const modeStartY = 330;
                const modeSpacing = 80;
                
                // Regular mode
                ctx.fillStyle = state.selectedModeIndex === 0 ? '#00ff00' : '#d3d3d3';
                ctx.fillText('Regular', GameConstants.SCREEN_WIDTH / 2, modeStartY);
                
                // Accelerated mode
                ctx.fillStyle = state.selectedModeIndex === 1 ? '#00ff00' : '#d3d3d3';
                ctx.fillText('Accelerated', GameConstants.SCREEN_WIDTH / 2, modeStartY + modeSpacing);
                
                // Selection indicator
                ctx.fillStyle = '#00ff00';
                ctx.font = '20px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('>', GameConstants.SCREEN_WIDTH / 2 - 150, 
                            modeStartY + (state.selectedModeIndex * modeSpacing) - 10);
                
                // Instructions
                ctx.fillStyle = '#d3d3d3';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Use UP/DOWN or W/S to select, SPACE or ENTER to confirm', 
                            GameConstants.SCREEN_WIDTH / 2, modeStartY + modeSpacing * 2 + 40);
            }
            
            static drawInstructionsScreen(ctx) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GameConstants.SCREEN_WIDTH, GameConstants.SCREEN_HEIGHT);
                
                // Title
                ctx.fillStyle = '#fff';
                ctx.font = '50px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SNAKE GAME', GameConstants.SCREEN_WIDTH / 2, 40);
                
                // Instructions header
                ctx.fillStyle = '#ffff00';
                ctx.font = '32px Arial';
                ctx.fillText('APPLE TYPES', GameConstants.SCREEN_WIDTH / 2, 110);
                
                // Apple type instructions
                ctx.font = '20px Arial';
                ctx.textAlign = 'left';
                let currentY = 160;
                const lineHeight = 28;
                const leftMargin = 40;
                
                // Regular Apple
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(leftMargin - 35, currentY - 2, 25, 25);
                ctx.fillStyle = '#fff';
                ctx.fillText('Regular Apple (Red) - 82%: Score +1, Grow +2 units', leftMargin, currentY + 20);
                currentY += lineHeight * 2;
                
                // Poisonous Apple
                ctx.fillStyle = GameConstants.POISON_COLOR;
                ctx.fillRect(leftMargin - 35, currentY - 2, 25, 25);
                ctx.fillStyle = '#fff';
                ctx.fillText('Poisonous Apple (Brown) - 10%: Reverses direction, 10s debuff', leftMargin, currentY + 20);
                ctx.fillStyle = '#d3d3d3';
                ctx.font = '18px Arial';
                ctx.fillText('  Cannot eat regular/purple apples during debuff', leftMargin + 10, currentY + lineHeight + 15);
                ctx.font = '20px Arial';
                currentY += lineHeight * 2;
                
                // Pomme Plus
                ctx.fillStyle = GameConstants.GOLD_COLOR;
                ctx.fillRect(leftMargin - 35, currentY - 2, 25, 25);
                ctx.fillStyle = '#fff';
                ctx.fillText('Pomme Plus (Orange) - 4%: Score +2, Resistance 10s', leftMargin, currentY + 20);
                ctx.fillStyle = '#d3d3d3';
                ctx.font = '18px Arial';
                ctx.fillText('  Can pass through own body, works when poisoned', leftMargin + 10, currentY + lineHeight + 15);
                ctx.font = '20px Arial';
                currentY += lineHeight * 2;
                
                // Pomme Supreme
                ctx.fillStyle = GameConstants.ENCHANTED_GOLD_COLOR;
                ctx.fillRect(leftMargin - 35, currentY - 2, 25, 25);
                ctx.fillStyle = '#fff';
                ctx.fillText('Pomme Supreme (Yellow) - 1%: Score +2, Resistance II 10s', leftMargin, currentY + 20);
                ctx.fillStyle = '#d3d3d3';
                ctx.font = '18px Arial';
                ctx.fillText('  Pass through body + walls, works when poisoned', leftMargin + 10, currentY + lineHeight + 15);
                ctx.font = '20px Arial';
                currentY += lineHeight * 2;
                
                // Purple Apple
                ctx.fillStyle = GameConstants.PURPLE_COLOR;
                ctx.fillRect(leftMargin - 35, currentY - 2, 25, 25);
                ctx.fillStyle = '#fff';
                ctx.fillText('Purple Apple (Purple) - 3%: Teleport to random location', leftMargin, currentY + 20);
                ctx.fillStyle = '#d3d3d3';
                ctx.font = '18px Arial';
                ctx.fillText('  No growth, cannot be eaten when poisoned', leftMargin + 10, currentY + lineHeight + 15);
                ctx.font = '20px Arial';
                currentY += lineHeight * 3;
                
                // Controls header
                ctx.fillStyle = '#ffff00';
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CONTROLS', GameConstants.SCREEN_WIDTH / 2, currentY);
                currentY += lineHeight + 10;
                
                // Controls
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Arrow Keys / WASD - Move', leftMargin, currentY);
                currentY += lineHeight;
                ctx.fillText('P - Pause/Unpause', leftMargin, currentY);
                currentY += lineHeight;
                ctx.fillText('Q - Show game over screen (or quit)', leftMargin, currentY);
                currentY += lineHeight;
                ctx.fillText('ESC - Exit game', leftMargin, currentY);
                currentY += lineHeight;
                ctx.fillText('R / Space - Restart (on game over)', leftMargin, currentY);
                currentY += lineHeight * 2;
                
                // Start prompt
                ctx.fillStyle = '#00ff00';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Press SPACE or ENTER to start', GameConstants.SCREEN_WIDTH / 2, currentY);
            }
            
            static drawGame(ctx, state) {
                // Clear screen
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GameConstants.SCREEN_WIDTH, GameConstants.SCREEN_HEIGHT);
                
                // Draw score area
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GameConstants.SCREEN_WIDTH, GameConstants.SCORE_AREA_HEIGHT);
                
                // Draw score
                ctx.fillStyle = '#fff';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Score: ${state.score}`, GameConstants.SCREEN_WIDTH / 2, 50);
                
                // Draw high score
                ctx.font = '24px Arial';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#d3d3d3';
                ctx.fillText(`High: ${state.getCurrentHighScore()}`, GameConstants.SCREEN_WIDTH - 20, 50);
                
                // Draw status effects
                ctx.font = '18px Arial';
                let statusY = 75;
                const statusRightMargin = 20;
                
                if (state.cannotEatApples && state.cannotEatTimer > 0) {
                    const countdown = Math.ceil(state.cannotEatTimer);
                    ctx.fillStyle = GameConstants.POISON_COLOR;
                    ctx.textAlign = 'right';
                    ctx.fillText(`Poisoned: ${countdown}`, GameConstants.SCREEN_WIDTH - statusRightMargin, statusY);
                    statusY += 21;
                }
                
                if (state.canIntersectSelf && state.immunityTimer > 0) {
                    const countdown = Math.ceil(state.immunityTimer);
                    ctx.fillStyle = GameConstants.GOLD_COLOR;
                    ctx.textAlign = 'right';
                    ctx.fillText(`Resistance: ${countdown}`, GameConstants.SCREEN_WIDTH - statusRightMargin, statusY);
                    statusY += 21;
                }
                
                if (state.canPassWalls && state.wallImmunityTimer > 0) {
                    const countdown = Math.ceil(state.wallImmunityTimer);
                    ctx.fillStyle = GameConstants.ENCHANTED_GOLD_COLOR;
                    ctx.textAlign = 'right';
                    ctx.fillText(`Resistance II: ${countdown}`, GameConstants.SCREEN_WIDTH - statusRightMargin, statusY);
                }
                
                // Draw white border
                const boardStartY = GameConstants.BOARD_START_Y;
                const cellSize = GameConstants.CELL_SIZE;
                ctx.fillStyle = '#fff';
                
                // Top border
                for (let col = 0; col < GameConstants.GRID_WIDTH + 2; col++) {
                    ctx.fillRect(col * cellSize, boardStartY, cellSize, cellSize);
                }
                // Bottom border
                for (let col = 0; col < GameConstants.GRID_WIDTH + 2; col++) {
                    ctx.fillRect(col * cellSize, boardStartY + (GameConstants.GRID_HEIGHT + 1) * cellSize, cellSize, cellSize);
                }
                // Left border
                for (let row = 1; row < GameConstants.GRID_HEIGHT + 1; row++) {
                    ctx.fillRect(0, boardStartY + row * cellSize, cellSize, cellSize);
                }
                // Right border
                for (let row = 1; row < GameConstants.GRID_HEIGHT + 1; row++) {
                    ctx.fillRect((GameConstants.GRID_WIDTH + 1) * cellSize, boardStartY + row * cellSize, cellSize, cellSize);
                }
                
                // Draw checkerboard
                for (let row = 0; row < GameConstants.GRID_HEIGHT; row++) {
                    for (let col = 0; col < GameConstants.GRID_WIDTH; col++) {
                        const screenCol = (col + GameConstants.BORDER_OFFSET) * cellSize;
                        const screenRow = boardStartY + (row + GameConstants.BORDER_OFFSET) * cellSize;
                        
                        if ((row + col) % 2 === 0) {
            ctx.fillStyle = '#000';
                        } else {
                            ctx.fillStyle = GameConstants.GRAY_COLOR;
                        }
                        ctx.fillRect(screenCol, screenRow, cellSize, cellSize);
                    }
                }
                
                // Draw apples
                for (const apple of state.apples) {
                    let foodColor;
                    if (apple.type === FoodType.POMME_SUPREME) {
                        foodColor = GameConstants.ENCHANTED_GOLD_COLOR;
                    } else if (apple.type === FoodType.POMME_PLUS) {
                        foodColor = GameConstants.GOLD_COLOR;
                    } else if (apple.type === FoodType.POISONOUS) {
                        foodColor = GameConstants.POISON_COLOR;
                    } else if (apple.type === FoodType.TELEPORT) {
                        foodColor = GameConstants.PURPLE_COLOR;
                    } else {
                        foodColor = '#ff0000';
                    }
                    
                    ctx.fillStyle = foodColor;
                    ctx.fillRect(
                        (apple.col + GameConstants.BORDER_OFFSET) * cellSize,
                        boardStartY + (apple.row + GameConstants.BORDER_OFFSET) * cellSize,
                        cellSize,
                        cellSize
                    );
                }
                
                // Draw snake body
                ctx.fillStyle = GameConstants.SNAKE_COLOR;
                for (let i = 1; i < state.snake.length; i++) {
                    const segment = state.snake[i];
                    ctx.fillRect(
                        (segment.col + GameConstants.BORDER_OFFSET) * cellSize,
                        boardStartY + (segment.row + GameConstants.BORDER_OFFSET) * cellSize,
                        cellSize,
                        cellSize
                    );
                }
                
                // Draw snake head
                if (state.snake.length > 0) {
                    ctx.fillStyle = GameConstants.SNAKE_HEAD_COLOR;
                    const head = state.snake[0];
                    ctx.fillRect(
                        (head.col + GameConstants.BORDER_OFFSET) * cellSize,
                        boardStartY + (head.row + GameConstants.BORDER_OFFSET) * cellSize,
                        cellSize,
                        cellSize
                    );
                }
            }
            
            static drawPauseOverlay(ctx, state) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, GameConstants.SCREEN_WIDTH, GameConstants.SCREEN_HEIGHT);
                
                ctx.fillStyle = '#fff';
                ctx.font = '60px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2 - 30);
                
                ctx.fillStyle = '#d3d3d3';
                ctx.font = '24px Arial';
                ctx.fillText('Press P to resume (or Q to quit)', GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2 + 50);
            }
            
            static drawResumeCountdown(ctx, state) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, GameConstants.SCREEN_WIDTH, GameConstants.SCREEN_HEIGHT);
                
                const countdown = Math.ceil(state.resumeDelayTimer);
                ctx.fillStyle = '#fff';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Resuming in ${countdown}...`, GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2);
            }
            
            static drawGameOverScreen(ctx, state) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, GameConstants.SCREEN_WIDTH, GameConstants.SCREEN_HEIGHT);
                
                ctx.fillStyle = '#fff';
                ctx.font = '60px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2 - 100);
                
                ctx.font = '40px Arial';
                ctx.fillText(`Final Score: ${state.score}`, GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2 - 20);
                
                ctx.fillStyle = '#ffff00';
                ctx.fillText(`High Score: ${state.getCurrentHighScore()}`, GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2 + 40);
                
                ctx.fillStyle = '#d3d3d3';
                ctx.font = '24px Arial';
                ctx.fillText('Press R or SPACE to restart', GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2 + 120);
                ctx.fillText('Press M to return to menu', GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2 + 155);
                ctx.fillText('Press ESC to exit or Q to quit', GameConstants.SCREEN_WIDTH / 2, GameConstants.SCREEN_HEIGHT / 2 + 190);
            }
        }

        // ==================== Main Game ====================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = new GameState();
                this.soundManager = new SoundManager();
                this.lastTime = 0;
                this.keys = {};
                this.keysPressed = {};
                
                this.init();
            }
            
            async init() {
                try {
                    document.getElementById('loading').style.display = 'none';
                    await this.soundManager.init();
                    this.setupEventListeners();
                    this.gameLoop(0);
                } catch (e) {
                    console.error('Failed to initialize game:', e);
                    document.getElementById('loading').textContent = 'Failed to load game. Check console for errors.';
                }
            }
            
            setupEventListeners() {
        document.addEventListener('keydown', (e) => {
                    if (!this.keys[e.key.toLowerCase()]) {
                        this.keysPressed[e.key.toLowerCase()] = true;
                    }
                    this.keys[e.key.toLowerCase()] = true;
                    e.preventDefault();
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    this.keysPressed[e.key.toLowerCase()] = false;
                    e.preventDefault();
                });
            }
            
            isKeyPressed(key) {
                return this.keysPressed[key.toLowerCase()] || false;
            }
            
            update(deltaTime) {
                // Handle ESC (always exits)
                if (this.isKeyPressed('Escape')) {
                    // Could close window or show confirmation
                    return;
                }
                
                // Handle mode selection screen
                if (this.state.showModeSelection) {
                    if (this.isKeyPressed('ArrowUp') || this.isKeyPressed('w')) {
                        this.state.selectedModeIndex = 0;
                    }
                    if (this.isKeyPressed('ArrowDown') || this.isKeyPressed('s')) {
                        this.state.selectedModeIndex = 1;
                    }
                    if (this.isKeyPressed(' ') || this.isKeyPressed('Enter')) {
                        this.state.gameMode = this.state.selectedModeIndex === 0 
                            ? GameMode.MODE_REGULAR 
                            : GameMode.MODE_ACCELERATED;
                        this.state.showModeSelection = false;
                        this.state.showInstructions = true;
                        
                        this.state.apples = [];
                        if (this.state.gameMode === GameMode.MODE_ACCELERATED) {
                            for (let i = 0; i < 3; i++) {
                                this.state.spawnApple(0.0);
                            }
                        } else {
                            this.state.spawnApple(0.0);
                        }
                    }
                    return;
                }
                
                // Handle instructions screen
                if (this.state.showInstructions) {
                    if (this.isKeyPressed(' ') || this.isKeyPressed('Enter')) {
                        this.state.showInstructions = false;
                        this.state.gameTime = 0.0;
                    }
                    return;
                }
                
                // Update game time
                if (!this.state.isUserPaused && !this.state.isResuming) {
                    this.state.gameTime += deltaTime;
                }
                
                // Update status effects
                if (!this.state.isUserPaused && !this.state.isResuming) {
                    this.updateStatusEffects(deltaTime);
                }
                this.updateAppleDespawn(deltaTime);
                
                // Handle input
                if (this.isKeyPressed('q')) {
                    if (!this.state.gameOver) {
                        this.state.gameOver = true;
                    }
                }
                
                if (!this.state.gameOver && this.isKeyPressed('p')) {
                    if (this.state.isUserPaused) {
                        this.state.isResuming = true;
                        this.state.resumeDelayTimer = GameConstants.RESUME_DELAY_DURATION;
                        this.state.pauseSoundTimer = 1.0;
                        this.state.isUserPaused = false;
                    } else if (!this.state.isResuming) {
                        this.state.isUserPaused = true;
                    }
                }
                
                // Handle game over restart and menu
                if (this.state.gameOver) {
                    if (this.isKeyPressed('r') || this.isKeyPressed(' ')) {
                        this.state.reset();
                    }
                    if (this.isKeyPressed('m')) {
                        this.state.gameOver = false;
                        this.state.showModeSelection = true;
                        this.state.showInstructions = false;
                        this.state.score = 0;
                        this.state.snake = [];
                        this.state.apples = [];
                        this.state.dx = 0;
                        this.state.dy = 0;
                        this.state.directionQueue = [];
                        this.state.moveTimer = 0.0;
                        this.state.gameTime = 0.0;
                        this.state.canIntersectSelf = false;
                        this.state.immunityTimer = 0.0;
                        this.state.canPassWalls = false;
                        this.state.wallImmunityTimer = 0.0;
                        this.state.cannotEatApples = false;
                        this.state.cannotEatTimer = 0.0;
                        this.state.isPaused = false;
                        this.state.pauseTimer = 0.0;
                        this.state.isUserPaused = false;
                        this.state.isResuming = false;
                        this.state.resumeDelayTimer = 0.0;
                        this.state.poisonSoundTimer = 0.0;
                        this.state.pauseSoundTimer = 0.0;
                        this.state.gameOverSoundPlayed = false;
                    }
                    return;
                }
                
                // Handle movement input
                if (!this.state.gameOver && !this.state.isUserPaused && !this.state.isResuming) {
                    if (this.isKeyPressed('ArrowUp') || this.isKeyPressed('w')) {
                        const newDir = { dx: 0, dy: -1 };
                        if (((this.state.dx === 0 && this.state.dy === 0) || this.state.dy !== 1) &&
                            (this.state.directionQueue.length === 0 ||
                             this.state.directionQueue[this.state.directionQueue.length - 1].dx !== newDir.dx ||
                             this.state.directionQueue[this.state.directionQueue.length - 1].dy !== newDir.dy)) {
                            this.state.directionQueue.push(newDir);
                        }
                    }
                    if (this.isKeyPressed('ArrowDown') || this.isKeyPressed('s')) {
                        const newDir = { dx: 0, dy: 1 };
                        if (((this.state.dx === 0 && this.state.dy === 0) || this.state.dy !== -1) &&
                            (this.state.directionQueue.length === 0 ||
                             this.state.directionQueue[this.state.directionQueue.length - 1].dx !== newDir.dx ||
                             this.state.directionQueue[this.state.directionQueue.length - 1].dy !== newDir.dy)) {
                            this.state.directionQueue.push(newDir);
                        }
                    }
                    if (this.isKeyPressed('ArrowLeft') || this.isKeyPressed('a')) {
                        const newDir = { dx: -1, dy: 0 };
                        if (((this.state.dx === 0 && this.state.dy === 0) || this.state.dx !== 1) &&
                            (this.state.directionQueue.length === 0 ||
                             this.state.directionQueue[this.state.directionQueue.length - 1].dx !== newDir.dx ||
                             this.state.directionQueue[this.state.directionQueue.length - 1].dy !== newDir.dy)) {
                            this.state.directionQueue.push(newDir);
                        }
                    }
                    if (this.isKeyPressed('ArrowRight') || this.isKeyPressed('d')) {
                        const newDir = { dx: 1, dy: 0 };
                        if (((this.state.dx === 0 && this.state.dy === 0) || this.state.dx !== -1) &&
                            (this.state.directionQueue.length === 0 ||
                             this.state.directionQueue[this.state.directionQueue.length - 1].dx !== newDir.dx ||
                             this.state.directionQueue[this.state.directionQueue.length - 1].dy !== newDir.dy)) {
                            this.state.directionQueue.push(newDir);
                        }
                    }
                }
                
                // Process game logic
                GameLogic.processMovement(this.state, deltaTime, this.soundManager);
                
                // Clear keys pressed
                this.keysPressed = {};
            }
            
            updateStatusEffects(deltaTime) {
                if (this.state.canIntersectSelf) {
                    this.state.immunityTimer -= deltaTime;
                    if (this.state.immunityTimer <= 0) {
                        this.state.canIntersectSelf = false;
                        this.state.immunityTimer = 0;
                    }
                }
                
                if (this.state.cannotEatApples) {
                    this.state.cannotEatTimer -= deltaTime;
                    
                    this.state.poisonSoundTimer -= deltaTime;
                    if (this.state.poisonSoundTimer <= 0) {
                        this.soundManager.play('poison');
                        this.state.poisonSoundTimer = 1.0;
                    }
                    
                    if (this.state.cannotEatTimer <= 0) {
                        this.state.cannotEatApples = false;
                        this.state.cannotEatTimer = 0;
                        this.state.poisonSoundTimer = 0;
                    }
                } else {
                    this.state.poisonSoundTimer = 0;
                }
                
                if (this.state.canPassWalls) {
                    this.state.wallImmunityTimer -= deltaTime;
                    if (this.state.wallImmunityTimer <= 0) {
                        this.state.canPassWalls = false;
                        this.state.wallImmunityTimer = 0;
                    }
                }
                
                if (this.state.isPaused) {
                    this.state.pauseTimer -= deltaTime;
                    if (this.state.pauseTimer <= 0) {
                        this.state.isPaused = false;
                        this.state.pauseTimer = 0;
                    }
                }
                
                if (this.state.isResuming) {
                    this.state.resumeDelayTimer -= deltaTime;
                    
                    this.state.pauseSoundTimer -= deltaTime;
                    if (this.state.pauseSoundTimer <= 0) {
                        this.soundManager.play('pause');
                        this.state.pauseSoundTimer = 1.0;
                    }
                    
                    if (this.state.resumeDelayTimer <= 0) {
                        this.state.isResuming = false;
                        this.state.resumeDelayTimer = 0;
                        this.state.pauseSoundTimer = 0;
                    }
                } else {
                    this.state.pauseSoundTimer = 0;
                }
            }
            
            updateAppleDespawn(deltaTime) {
                if (this.state.gameMode !== GameMode.MODE_ACCELERATED) {
                    return;
                }
                
                // Remove apples that have exceeded their despawn time
                this.state.apples = this.state.apples.filter(apple => {
                    const elapsed = this.state.gameTime - apple.spawnTime;
                    return elapsed < apple.despawnTime;
                });
                
                // Ensure at least MIN_APPLES apples are on the board
                while (this.state.apples.length < GameConstants.MIN_APPLES) {
                    if (!this.state.spawnApple(this.state.gameTime)) {
                        break;
                    }
                }
            }
            
            draw() {
                if (this.state.showModeSelection) {
                    Renderer.drawModeSelectionScreen(this.ctx, this.state);
                } else if (this.state.showInstructions) {
                    Renderer.drawInstructionsScreen(this.ctx);
                } else {
                    Renderer.drawGame(this.ctx, this.state);
                    
                    if (this.state.isUserPaused && !this.state.gameOver) {
                        Renderer.drawPauseOverlay(this.ctx, this.state);
                    }
                    
                    if (this.state.isResuming && !this.state.gameOver) {
                        Renderer.drawResumeCountdown(this.ctx, this.state);
                    }
                    
                    if (this.state.gameOver) {
                        Renderer.drawGameOverScreen(this.ctx, this.state);
                    }
                }
            }
            
            gameLoop(currentTime) {
                const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.draw();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }

        // Start the game
        const game = new Game();
    </script>
</body>
</html>
